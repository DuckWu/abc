###############################################################
#  digitaldocs‑cte.conf
#  Handles “print” and non‑print JSON files in one pipeline
###############################################################

############################
#  INPUT (unchanged)
############################
input {
  file {
    id                     => "main_input_file"
    path                   => "${LS_XML_PATH:/data/logstash/esingest/metadata/digitaldocs/letters/ods}/*.json"
    start_position         => "beginning"
    sincedb_path           => "${LS_DATA_LOG_PATH:/data/logstash/data}/cte5_input_sincedb.log"
    type                   => "plain"
    mode                   => "read"
    exclude                => "*.gz"
    file_completed_action  => "log_and_delete"
    file_completed_log_path=> "${LS_DATA_LOG_PATH:/data/logstash/data}/cte5_input_processedFile.log"
  }
}

############################
#  FILTER
############################
filter {

  # 0.  Derive [filename] from [path] for branching
  ruby {
    id   => "extract_filename"
    code => '
      path = event.get("path")
      event.set("filename", File.basename(path)) if path
    '
  }

  # 1.  Logic that ALL files share  ────────────────────────────
  if "totalCount" in [message] and [message] =~ /\[$/ {
    ruby {
      id   => "log_totalCount_by_ruby"
      code => '
        msg   = event.get("message")
        match = msg.match(/.*totalCount[^0-9]+(\d+)/).captures
        if match
          logger.info("CTE ingest document count[" +
                      match[0] + "] time[" + Time.now.utc.to_s +
                      "] in file[" + event.get("path") + "]")
        end
      '
    }
    drop { id => "drop_totalCount_event" }
  }

  # 2.  Branch on filename containing "print"  ────────────────
  if "print" in [filename] {

    ##########################
    #  PRINT BRANCH
    ##########################
    mutate { id => "add_vendorName_ods" add_field => { "vendorName" => "ods" } }

    mutate { strip => ["message"] }
    if [message] == ']}' or [message] == '' { drop {} }
    mutate { gsub => ["message", ",$", ""] }
    json   { source => "message" }

    ruby {
      id   => "index_create_print"
      path => "${LS_SCRIPT_PATH:/data/logstash/scripts/ruby}/index-create.rb"
      script_params => {
        "indexNamePrefix"   => "digitaldocs-cte"
        "nasPdfBasePath"    => "${nasPdfBasePath:/data/documents/portal_member_bills}"
        "nasReportType"     => "${reportType:daily}"
        "useTimestampField" => "true"
        "timestampFieldName"=> "documentReportDate"
      }
    }

    if ![@metadata][indexName] { drop {} }

    mutate { strip => ["documentId"] }

    ruby {
      id => "logger_print"
      code => '
        event.set("[@metadata][updateDate]", Time.now.utc)
        did = event.get("documentId")
        logger.error("documentId missing in " + event.get("path")) if did.nil? || did.empty?
      '
    }

    if ([documentId] and [documentId] != "") {
      mutate {
        add_field => { "lastUpdate3Date" => "%{[@metadata][updateDate]}"
                       "[metadata][path3]" => "%{path}" }
      }
    } else {
      drop {}
    }

    mutate { remove_field => ["message","tags","@version","@timestamp",
                              "path","host","type","appliancePrintInfo"] }

    if [documentPath] { mutate { remove_field => ["documentPath"] } }

    ##########################
    #  END PRINT BRANCH
    ##########################

  } else {

    ##########################
    #  DEFAULT BRANCH
    ##########################
    mutate { strip => ["message"] }
    mutate { gsub  => ["message", "\r\n", "\n"] }
    if [message] == ']}' or [message] == '' { drop {} }
    mutate { gsub => ["message", ",$", ""] }
    json   { source => "message" }

    ruby {
      id   => "index_create_default"
      path => "${LS_SCRIPT_PATH:/data/logstash/scripts/ruby}/index-create.rb"
      script_params => {
        "indexNamePrefix"   => "digitaldocs-cte"
        "nasPdfBasePath"    => "${nasPdfBasePath:/nfs/data/documents/odsltrs}"
        "nasReportType"     => "${reportType:daily}"
        "useTimestampField" => "true"
        "timestampFieldName"=> "documentReportDate"
        "generateDocBasePathFromDocPath" => "true"
        "docPathFieldName"  => "documentPath"
      }
    }

    if ![@metadata][indexName] { drop {} }

    mutate { strip => ["documentId"] }

    ruby {
      id => "logger_default"
      code => '
        event.set("[@metadata][updateDate]", Time.now.utc)
        did = event.get("documentId")
        logger.error("documentId missing in " + event.get("path")) if did.nil? || did.empty?
      '
    }

    if ([documentId] and [documentId] != "") {
      mutate {
        add_field => { "lastUpdate2Date" => "%{[@metadata][updateDate]}"
                       "[metadata][path2]" => "%{path}" }
      }

      if ([@metadata][useDocBasePathOnly]) {
        mutate { replace => { "documentPath" => "%{[@metadata][docBasePath]}" } }
      } else {
        mutate { replace => { "documentPath" => "%{[@metadata][docBasePath]}/%{documentPath}" } }
      }
    } else {
      drop {}
    }

    if ([metadata]) {
      if [metadata][batchSentToUSPS] { mutate { lowercase => ["[metadata][batchSentToUSPS]"] } }
      ruby {
        id => "check_brcc_composed"
        code => '
          p = event.get("path")
          if p =~ /bsc_sc_accrual_ntc_(daily|monthly)_(dmhc|doi)_letter_/
            event.set("isBRCCComposed", true)
          end
        '
      }
    }

    mutate { remove_field => ["message","tags","@version","@timestamp",
                              "path","host","type","appliancePrintInfo"] }

    ##########################
    #  END DEFAULT BRANCH
    ##########################
  }
}

############################
#  OUTPUT (unchanged)
############################
output {
  elasticsearch {
    id             => "main_es"
    hosts          => ["https://es1-edocsmd-dev01:9200"]
    user           => "svc_es_logstsh_npe"
    password       => "${svc_es_logstsh_npe_password}"
    ssl            => true
    cacert         => "/opt/logstash/logstash/config/certs/ca.crt"
    index          => "%{[@metadata][indexName]}"
    document_id    => "%{documentId}"
    sniffing       => true
    action         => "update"
    doc_as_upsert  => true
  }
}
